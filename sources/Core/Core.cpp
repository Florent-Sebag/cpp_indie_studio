/*** Core.cpp for new in /home/sshsupreme/tek2/new/sources/Core**** Made by sshSupreme** Login   <sshsupreme@epitech.net>**** Started on  Wed May 17 16:52:13 2017 sshSupreme// Last update Sun Jun 18 19:00:45 2017 chauvin*/#include <memory>#include "Core.hpp"#include "../../libraries/irrlicht/include/aabbox3d.h"enum{  // I use this ISceneNode ID to indicate a scene node that is  // not pickable by getSceneNodeAndCollisionPointFromRay()	  ID_IsNotPickable = 0,  // I use this flag in ISceneNode IDs to indicate that the  // scene node can be picked by ray selection.	  IDFlag_IsPickable = 1 << 0,  // I use this flag in ISceneNode IDs to indicate that the  // scene node can be highlighted.  In this example, the  // homonids can be highlighted, but the level mesh can't.	  IDFlag_IsHighlightable = 1 << 1}; void                              NsCore::Core::InitializationTextures(){  NsManager::NsTexturesManager_.addTexture("defeat",					   "./ressources/End/GameOver.png");  NsManager::NsTexturesManager_.addTexture("press",					   "./ressources/End/press_cross.jpg");  NsManager::NsTexturesManager_.addTexture("fire",					   "./ressources/Models/fire.bmp");  NsManager::NsTexturesManager_.addTexture("titre",					   "./ressources/SplashScreen/titre.png");  NsManager::NsTexturesManager_.addTexture("start",					   "./ressources/SplashScreen/start.png");  NsManager::NsTexturesManager_.addTexture("home_play",					   "./ressources/Menu/home_play.png");  NsManager::NsTexturesManager_.addTexture("home_settings",					   "./ressources/Menu/home_settings.png");  NsManager::NsTexturesManager_.addTexture("home_credits",					   "./ressources/Menu/home_credits.png");  NsManager::NsTexturesManager_.addTexture("home_exit",					   "./ressources/Menu/home_exit.png");  NsManager::NsTexturesManager_.addTexture("credits",					   "./ressources/Menu/credits.png");  NsManager::NsTexturesManager_.addTexture("audio0",					   "./ressources/Menu/settings_audio0.png");  NsManager::NsTexturesManager_.addTexture("audio1",					   "./ressources/Menu/settings_audio1.png");  NsManager::NsTexturesManager_.addTexture("audio2",					   "./ressources/Menu/settings_audio2.png");  NsManager::NsTexturesManager_.addTexture("audio3",					   "./ressources/Menu/settings_audio3.png");  NsManager::NsTexturesManager_.addTexture("audio4",					   "./ressources/Menu/settings_audio4.png");  NsManager::NsTexturesManager_.addTexture("settings_controls",					   "./ressources/Menu/settings_controls.png");  NsManager::NsTexturesManager_.addTexture("controls",					   "./ressources/Menu/controls.png");  NsManager::NsTexturesManager_.addTexture("settings_back",					   "./ressources/Menu/settings_back.png");  NsManager::NsTexturesManager_.addTexture("warriorP1",					   "./ressources/Menu/warriorP1.png");  NsManager::NsTexturesManager_.addTexture("warriorP2",					   "./ressources/Menu/warriorP2.png");  NsManager::NsTexturesManager_.addTexture("warriorP3",					   "./ressources/Menu/warriorP3.png");  NsManager::NsTexturesManager_.addTexture("warriorP4",					   "./ressources/Menu/warriorP4.png");  NsManager::NsTexturesManager_.addTexture("archerP1",					   "./ressources/Menu/archerP1.png");  NsManager::NsTexturesManager_.addTexture("archerP2",					   "./ressources/Menu/archerP2.png");  NsManager::NsTexturesManager_.addTexture("archerP3",					   "./ressources/Menu/archerP3.png");  NsManager::NsTexturesManager_.addTexture("archerP4",					   "./ressources/Menu/archerP4.png");  NsManager::NsTexturesManager_.addTexture("wizardP1",					   "./ressources/Menu/wizardP1.png");  NsManager::NsTexturesManager_.addTexture("wizardP2",					   "./ressources/Menu/wizardP2.png");  NsManager::NsTexturesManager_.addTexture("wizardP3",					   "./ressources/Menu/wizardP3.png");  NsManager::NsTexturesManager_.addTexture("wizardP4",					   "./ressources/Menu/wizardP4.png");  NsManager::NsTexturesManager_.addTexture("guardianP1",					   "./ressources/Menu/guardianP1.png");  NsManager::NsTexturesManager_.addTexture("guardianP2",					   "./ressources/Menu/guardianP2.png");  NsManager::NsTexturesManager_.addTexture("guardianP3",					   "./ressources/Menu/guardianP3.png");  NsManager::NsTexturesManager_.addTexture("guardianP4",					   "./ressources/Menu/guardianP4.png");  NsManager::NsTexturesManager_.addTexture("ATH_archer",					   "./ressources/ATH/archer.png");  NsManager::NsTexturesManager_.addTexture("ATH_guardian",					   "./ressources/ATH/guardian.png");  NsManager::NsTexturesManager_.addTexture("ATH_warrior",					   "./ressources/ATH/warrior.png");  NsManager::NsTexturesManager_.addTexture("ATH_wizard",					   "./ressources/ATH/wizard.png");  NsManager::NsTexturesManager_.addTexture("youwin",					   "./ressources/End/youwin.png");}void                              NsCore::Core::InitializationModels(){  NsManager::NsModelsManager_.addModel("wizard", "./ressources/Models/wizard/wizard.ms3d");  NsManager::NsModelsManager_.addModel("archer", "./ressources/Models/archere/archere.ms3d");  NsManager::NsModelsManager_.addModel("warrior", "./ressources/Models/warrior/warrior.ms3d");  NsManager::NsModelsManager_.addModel("guardian", "./ressources/Models/guardian/guardian.ms3d");  NsManager::NsModelsManager_.addModel("basicmonster", "./ressources/Models/monstre1/monstre1.ms3d");  NsManager::NsModelsManager_.addModel("coin", "./ressources/Models/coin/coin.ms3d");  NsManager::NsModelsManager_.addModel("key", "./ressources/Models/key/gold_key.obj");  NsManager::NsModelsManager_.addModel("door", "./ressources/Models/Door/door.ms3d");  NsManager::NsModelsManager_.addModel("door2", "./ressources/Models/Door/door_egypte.ms3d");  NsManager::NsModelsManager_.addModel("door3", "./ressources/Models/Door/door_egypte_two.ms3d");  NsManager::NsModelsManager_.addModel("boss", "./ressources/Models/boss1/boss1.ms3d");}void                              NsCore::Core::InitializationAudio(){  NsManager::NsAudioManager_.addMusic("menu", "./ressources/audio/menu.wav");  NsManager::NsAudioManager_.addSound("sword", "./ressources/audio/epee.wav");  NsManager::NsAudioManager_.addSound("fireball", "./ressources/audio/fireball.wav");  NsManager::NsAudioManager_.addSound("takecoin", "./ressources/audio/coin.wav");  // NsManager::NsAudioManager_.addSound("fireball", "./ressources/audio/fireball.wav");}void 				NsCore::Core::InitializationFonts(){  NsManager::NsFontsManager_.addFont("ath", "./ressources/Fonts/ATH/ath.xml");}void                              NsCore::Core::InitializationCamera(){  NsGUI::GraphicsEngine &engine = NsGUI::GraphicsEngine::Instance();  engine.Scene()->addCameraSceneNode(engine.Scene()->getRootSceneNode(), irr::core::vector3df(0, 0, 0), irr::core::vector3df(0, 0, 0));}void                              NsCore::Core::PushEnnemyEntity(std::shared_ptr<NsEntity::EnnemyEntity> entity, const irr::core::vector3df& Pos, scene::ITriangleSelector *selector, int roomId){  NsGUI::GraphicsEngine &engine = NsGUI::GraphicsEngine::Instance();  irr::scene::IAnimatedMeshSceneNode *node = engine.Scene()->addAnimatedMeshSceneNode(entity->getModel().getMesh());  node->setPosition(Pos);  node->setMaterialFlag(irr::video::EMF_LIGHTING, false);  core::aabbox3df box = node->getBoundingBox();  core::vector3df radius = box.MaxEdge - box.getCenter();  scene::ISceneNodeAnimator* anim = engine.Scene()->createCollisionResponseAnimator(selector, node, radius,										    core::vector3df(0,-10,0), core::vector3df(0,0,0));  node->addAnimator(anim);  // anim->drop();  // And likewise, drop the animator when we're done referring to it.  entity->setNode(node);  entity->Initialization();  scene::ISceneCollisionManager* coll = engine.Scene()->getSceneCollisionManager();  scene::HealthSceneNode* m_pgHealthBar = new scene::HealthSceneNode(node, engine.Scene(), 1, coll,								     50, // width								     6, // height								     core::vector3df(0,node->getBoundingBox().MaxEdge.Y,0), // position								     video::SColor(150,0,200,0), // bar color								     video::SColor(150,220,0,0), // background color								     video::SColor(0,0,0,0)); // boarder color//set percent of health	// node->setFrameLoop(39,39);  m_pgHealthBar->setProgress((s32) (100 * entity->getHealth() / entity->getMaxHealth()));  entity->setHealthbar(m_pgHealthBar);  entity->setRoom_id_(roomId);  vEnnemy_.push_back(entity);  std::cout << "ADD ENNEMY" << std::endl;}void                              NsCore::Core::PushPlayableEntity(std::shared_ptr<NsEntity::PlayableEntity> entity, const irr::core::vector3df& Pos, scene::ITriangleSelector *selector){  NsGUI::GraphicsEngine &engine = NsGUI::GraphicsEngine::Instance();  irr::scene::IAnimatedMeshSceneNode *node = engine.Scene()->addAnimatedMeshSceneNode(entity->getModel().getMesh());  node->setPosition(Pos);  node->setMaterialFlag(irr::video::EMF_LIGHTING, false);  core::aabbox3df box = node->getBoundingBox();  core::vector3df radius = box.MaxEdge - box.getCenter();  scene::ISceneNodeAnimator* anim = engine.Scene()->createCollisionResponseAnimator(selector, node, radius,										    core::vector3df(0,-10,0), core::vector3df(0,0,0));  node->addAnimator(anim);  // anim->drop();  // And likewise, drop the animator when we're done referring to it.  entity->setNode(node);  entity->Initialization();  entity->Static();  vPlayer_.push_back(entity);}void                              NsCore::Core::PushGameObject(std::shared_ptr<NsGameObject::GameObject> entity, const irr::core::vector3df& Pos, scene::ITriangleSelector *selector){  NsGUI::GraphicsEngine &engine = NsGUI::GraphicsEngine::Instance();  irr::scene::IAnimatedMeshSceneNode *node = engine.Scene()->addAnimatedMeshSceneNode(entity->getModel3D_().getMesh());  node->setPosition(Pos);  node->setMaterialFlag(irr::video::EMF_LIGHTING, false);  core::aabbox3df box = node->getBoundingBox();  core::vector3df radius = box.MaxEdge - box.getCenter();  scene::ISceneNodeAnimator* anim = engine.Scene()->createCollisionResponseAnimator(selector, node, radius,										    core::vector3df(0,-10,0), core::vector3df(0,0,0));  node->addAnimator(anim);  node->setScale(core::vector3df(100, 100, 100));  node->setAnimationSpeed(0);  entity->setNode_(node);  entity->Initialization();  vObject_.push_back(entity);}// Adds a skydome to the scenevoid NsCore::Core::AddSky(){  NsGUI::GraphicsEngine &engine = NsGUI::GraphicsEngine::Instance();  //! RESSOURCE MANAGER A VOIR  engine.Driver()->setTextureCreationFlag(video::ETCF_CREATE_MIP_MAPS, false);  scene::ISceneNode* skybox=engine.Scene()->addSkyBoxSceneNode(	  engine.Driver()->getTexture("./ressources/Skybox/irrlicht2_up.jpg"),	  engine.Driver()->getTexture("./ressources/Skybox/irrlicht2_dn.jpg"),	  engine.Driver()->getTexture("./ressources/Skybox/irrlicht2_lf.jpg"),	  engine.Driver()->getTexture("./ressources/Skybox/irrlicht2_rt.jpg"),	  engine.Driver()->getTexture("./ressources/Skybox/irrlicht2_ft.jpg"),	  engine.Driver()->getTexture("./ressources/Skybox/irrlicht2_bk.jpg"));  scene::ISceneNode* skydome=engine.Scene()->addSkyDomeSceneNode(engine.Driver()->getTexture("./ressources/Skydome/skydome.jpg"),16,8,0.95f,2.0f);  engine.Driver()->setTextureCreationFlag(video::ETCF_CREATE_MIP_MAPS, true);  skybox->setVisible(true);  skydome->setVisible(false);}scene::ITriangleSelector *NsCore::Core::createMap(){  NsGUI::GraphicsEngine &engine = NsGUI::GraphicsEngine::Instance();  irr::scene::IAnimatedMesh* map = engine.Scene()->getMesh( "./ressources/Map/map.obj");  irr::scene::IMeshSceneNode* node= 0;  scene::ITriangleSelector* selector = 0;  if (map)    {      node = engine.Scene()->addOctreeSceneNode(map->getMesh(0), 0, IDFlag_IsPickable);      node->setScale(core::vector3df(50, 50, 50));    }  if (node)    {      selector = engine.Scene()->createOctreeTriangleSelector(node->getMesh(), node, 128);      node->setTriangleSelector(selector);      node->setMaterialFlag(irr::video::EMF_LIGHTING, false);      this->map_ = node;    }  return (selector);}void                              NsCore::Core::Initialization(){  NsGUI::GraphicsEngine &engine = NsGUI::GraphicsEngine::Instance();  srand(time(NULL));  this->InitializationModels();  this->InitializationAudio();  this->InitializationTextures();  this->InitializationFonts();  this->Menu_.Initialization();  this->GAMESTATE_ = NsCore::GAMESTATE::MENU;  this->selector = this->createMap();  this->AddSky();  this->InitializationCamera();  core::vector3df pos (0, 0, 0);  distance = 0;  midpoint = pos;  for (auto i = vPlayer_.begin(); i < vPlayer_.end(); i++)    {      pos = (*i)->getNode()->getPosition();      midpoint += pos;      distance += pos.getDistanceFrom(engine.Scene()->getActiveCamera()->getTarget());    }}void                              NsCore::Core::MenuHandler(){  std::vector<int> state;  state = this->Menu_.launcher();  if (state.at(0) == -1)    {      this->GAMESTATE_ = NsCore::GAMESTATE::EXIT;      return;    } else {      for (auto it = state.begin() ; it < state.end() ; ++it) EntitySelected((*it));      this->GAMESTATE_ = NsCore::GAMESTATE::GAMELOOP;    }  _state = state;}void                							NsCore::Core::ProjectilTick(){  vProjectil_.erase(std::remove_if(vProjectil_.begin(), vProjectil_.end(), [&](auto i)  {    if ((*i).isAlive() == true)      return (false);    this->DeleteEntityScreen<NsProjectil::Projectil&>(*i);    return (true);  }), vProjectil_.end());  for (auto i = vProjectil_.begin(); i < vProjectil_.end(); i++)    {      (*i)->Move();      (*i)->CheckCollision(vEnnemy_);    }}void                              NsCore::Core::CameraTick(){  NsGUI::GraphicsEngine &engine = NsGUI::GraphicsEngine::Instance();  if (distance < 250)    distance = 250;  else if (distance > 800)      distance = 800;  irr::core::vector3df offset(0.f, (f32) distance, 150.f);  engine.Scene()->getActiveCamera()->setPosition(midpoint + offset);  engine.Scene()->getActiveCamera()->setTarget(midpoint);  engine.Scene()->getActiveCamera()->updateAbsolutePosition();}void                              NsCore::Core::EngineTick() // simple refresh and run of the irrlicht library{  NsGUI::GraphicsEngine &engine = NsGUI::GraphicsEngine::Instance();  if (engine.Device()->run() == false)    this->GAMESTATE_ = NsCore::GAMESTATE::EXIT;  else    {      this->CameraTick();      engine.Refresh(GameGUI);    }}template <typename T> void        NsCore::Core::DeleteEntityScreen(T &entity){  NsGUI::GraphicsEngine &engine = NsGUI::GraphicsEngine::Instance();  engine.Scene()->addToDeletionQueue(entity.getNode());}void                              NsCore::Core::EnnemyTick() // ennemy IA{  IA_.defPlayerList(vPlayer_);  irr::core::vector3df focus;  vEnnemy_.erase(std::remove_if(vEnnemy_.begin(), vEnnemy_.end(), [&](auto i) {    if ((*i).isAlive() == true)      return (false);    this->DeleteEntityScreen<NsEntity::EnnemyEntity&>(*i);    return (true);  }), vEnnemy_.end());  for (auto i = vEnnemy_.begin(); i < vEnnemy_.end(); i++)    {      if ((*i)->getNode()->getPosition().Y < 0)				(*i)->setHealth(0);      irr::core::vector3df pos = (*i)->getNode()->getPosition();      focus = IA_.LaunchIA(pos.X, pos.Y, pos.Z);      (*i)->Move(focus, 0, vEnnemy_);      (*i)->UpdateCoolDown();      if ((*i)->getableAttack_())				IA_.attack((*i), vPlayer_, focus);    }  Py_DECREF(IA_.getTlistPlayer());}void                              NsCore::Core::PlayerTick() // read all command for all players and execute them{  NsGUI::GraphicsEngine &engine = NsGUI::GraphicsEngine::Instance();  for (auto i = engine.getVEvents().begin(); i < engine.getVEvents().end(); i++) { // loop over all the player event input      if (vPlayer_[(*i)->getPlayerID()]->getNode()->getPosition().Y < 0)	vPlayer_[(*i)->getPlayerID()]->setHealth(0);      if (!vPlayer_[(*i)->getPlayerID()]->isAlive() && vPlayer_[(*i)->getPlayerID()]->getIsDying())	{	  vPlayer_[(*i)->getPlayerID()]->getNode()->setLoopMode(false);	  vPlayer_[(*i)->getPlayerID()]->setIsDying(false);	  if (_state[(*i)->getPlayerID()] == 0)	    vPlayer_[(*i)->getPlayerID()]->getNode()->setFrameLoop(38, 49);	  else if (_state[(*i)->getPlayerID()] == 1)	      vPlayer_[(*i)->getPlayerID()]->getNode()->setFrameLoop(66, 77);	    else if (_state[(*i)->getPlayerID()] == 2)		vPlayer_[(*i)->getPlayerID()]->getNode()->setFrameLoop(42, 59);	      else		vPlayer_[(*i)->getPlayerID()]->getNode()->setFrameLoop(48, 59);	}      else if (vPlayer_[(*i)->getPlayerID()]->isAlive())	  {	    vPlayer_[(*i)->getPlayerID()]->UpdateCoolDown();	    if ((*i)->getSQUARE())	      vPlayer_[(*i)->getPlayerID()]->Spell_1();	    if ((*i)->getTRIANGLE())	      vPlayer_[(*i)->getPlayerID()]->Spell_2();	    if ((*i)->getCIRCLE())	      vPlayer_[(*i)->getPlayerID()]->Spell_3();	    if ((*i)->getCROSS())	      vPlayer_[(*i)->getPlayerID()]->Jump();	    if ((*i)->getJLEFT())	      this->CheckDist(i);	    else	      vPlayer_[(*i)->getPlayerID()]->Static();	    if ((*i)->getR1())	      vPlayer_[(*i)->getPlayerID()]->AutoShot(vEnnemy_, vProjectil_);	    else	      vPlayer_[(*i)->getPlayerID()]->StopShot();	  }    }}void                              NsCore::Core::GameTick(){  this->PlayerTick();  this->EnnemyTick();  this->ProjectilTick();  this->RoomsTick();  this->GameObjectTick();}void				  NsCore::Core::AddModelsSplash(){  this->PushPlayableEntity(std::make_shared<NsEntity::Guardian>(NsManager::NsModelsManager_.getModel("guardian")), irr::core::vector3df(-1534, 600, -4207), selector);  this->PushPlayableEntity(std::make_shared<NsEntity::Archer>(NsManager::NsModelsManager_.getModel("archer")), irr::core::vector3df(-1512, 600, -5017), selector);  this->PushPlayableEntity(std::make_shared<NsEntity::Warrior>(NsManager::NsModelsManager_.getModel("warrior")), irr::core::vector3df(-716, 600, -4984), selector);  this->PushPlayableEntity(std::make_shared<NsEntity::Wizard>(NsManager::NsModelsManager_.getModel("wizard")), irr::core::vector3df(-703, 600, -4229), selector);  this->vPlayer_[0]->getNode()->setScale(irr::core::vector3df(2, 2 , 2));  this->vPlayer_[0]->getNode()->setFrameLoop(62, 74);  this->vPlayer_[0]->getNode()->setRotation(irr::core::vector3df(0, 180, 0));  this->vPlayer_[1]->getNode()->setScale(irr::core::vector3df(2, 2 , 2));  this->vPlayer_[1]->getNode()->setFrameLoop(80, 104);  this->vPlayer_[1]->getNode()->setRotation(irr::core::vector3df(0, 180, 0));  this->vPlayer_[2]->getNode()->setScale(irr::core::vector3df(2, 2 , 2));  this->vPlayer_[2]->getNode()->setFrameLoop(52, 76);  this->vPlayer_[2]->getNode()->setRotation(irr::core::vector3df(0, 180, 0));  this->vPlayer_[3]->getNode()->setScale(irr::core::vector3df(2, 2 , 2));  this->vPlayer_[3]->getNode()->setFrameLoop(62, 80);  this->vPlayer_[3]->getNode()->setRotation(irr::core::vector3df(0, 180, 0));}void				  NsCore::Core::DelModelsSplash(){  vPlayer_.erase(std::remove_if(vPlayer_.begin(), vPlayer_.end(), [&](auto i) {    this->DeleteEntityScreen<NsEntity::PlayableEntity&>(*i);    return (true);  }), vPlayer_.end());}void NsCore::Core::EntitySelected(int player) {  switch (player) {      case 0:	this->PushPlayableEntity(std::make_shared<NsEntity::Warrior>(NsManager::NsModelsManager_.getModel("warrior")), irr::core::vector3df(133.343,33.8633,802.346), selector);      break;      case 1:	this->PushPlayableEntity(std::make_shared<NsEntity::Archer>(NsManager::NsModelsManager_.getModel("archer")), irr::core::vector3df(27.8155,28.7543,860.837), selector);      break;      case 2:	this->PushPlayableEntity(std::make_shared<NsEntity::Wizard>(NsManager::NsModelsManager_.getModel("wizard")), irr::core::vector3df(-96.2606,30.395,885.447), selector);      break;      case 3:	this->PushPlayableEntity(std::make_shared<NsEntity::Guardian>(NsManager::NsModelsManager_.getModel("guardian")), irr::core::vector3df(-215.894,46.8849,844.5), selector);      break;      default:	break;    }}void                              NsCore::Core::StartGame(){  NsGUI::GraphicsEngine &engine = NsGUI::GraphicsEngine::Instance();  std::chrono::high_resolution_clock::time_point t1 = std::chrono::high_resolution_clock::now();  std::chrono::high_resolution_clock::time_point t2;  NsManager::NsAudioManager_.getMusic("menu")->getMusic().play();  AddModelsSplash();  Splash.LaunchSplashScreen();  DelModelsSplash();  while (GAMESTATE_ != NsCore::GAMESTATE::EXIT)    {      //! Bug sans manette et ne gère pas manette PS4      // NsManager::NsAudioManager_.getMusic("menu")->getMusic().play();      this->MenuHandler(); // where menu have to decide if play or exit      std::cout << "Start reading Mapfile" << std::endl;      this->Spawn_.Initialization(1, vPlayer_.size(), "./.Maps/1.map");      this->generateDoors();      this->GameGUI = new CGUIGame(engine.Driver(), _state, vPlayer_, 100, 100);      std::cout << "End reading Mapfile" << std::endl;      this->setCameraStart();      this->PushGameObject(std::make_shared<NsGameObject::Key>(NsManager::NsModelsManager_.getModel("key")), irr::core::vector3df(-2.85825 ,41.8871,346.018), selector);      // NsManager::NsAudioManager_.getMusic("menu")->getMusic().stop();      while (GAMESTATE_ != NsCore::GAMESTATE::EXIT && GAMESTATE_ != NsCore::GAMESTATE::MENU) // loop to change with timer	{	  t2 = std::chrono::high_resolution_clock::now();	  std::chrono::duration<double> time_span = std::chrono::duration_cast<std::chrono::duration<double>>(t2 - t1);	  if (time_span > (std::chrono::duration<double>)_TICK_)	    {	      this->GameTick(); // 1 step ahead for the game	      t1 = std::chrono::high_resolution_clock::now();	    }	  this->EngineTick(); // 1 step ahead for the graphic library	  end = this->check_end();	  end_or_not();	}      free_world();    }}void	NsCore::Core::end_or_not(){  NsGUI::GraphicsEngine &engine = NsGUI::GraphicsEngine::Instance();  if (this->end == 0)    return ;  else    if (this->end == -1)      {	while (engine.Device()->run()){	    if ((*engine.getVEvents().begin())->getCROSS())	      break ;	    engine.Refresh_Defeat();	  }      }    else      while (engine.Device()->run()){	  if ((*engine.getVEvents().begin())->getCROSS())	    break ;	  engine.Refresh_Victory();	}}NsCore::Core::Core() : Score_("ressources/score/score .data"),		       Settings_("ressources/score/settings.data"){  this->Initialization(); // all necessary initialization for the game (font, texture ...)  this->Splash.Initialisation();}NsCore::Core::~Core(){}void NsCore::Core::CheckDist(std::vector<std::shared_ptr<NsEvents::KeyInput>>::iterator i){  std::vector<std::shared_ptr<NsEntity::PlayableEntity>>::iterator j;  std::vector<std::shared_ptr<NsGameObject::GameObject>>::iterator k;  NsGUI::GraphicsEngine &engine = NsGUI::GraphicsEngine::Instance();  core::vector3df pos(0, 0, 0);  int 				size = 0;  vPlayer_[(*i)->getPlayerID()]->Move((*i)->getJLEFTVALUE_Y(), (*i)->getJLEFTVALUE_X());  distance = 0;  midpoint = pos;  for (j = vPlayer_.begin(); j < vPlayer_.end(); j++)    {      if ((*j)->isAlive())	{	  size++;	  pos = (*j)->getNode()->getPosition();	  // pos.Y = 0;	  midpoint += pos;	  distance += pos.getDistanceFrom(		  engine.Scene()->getActiveCamera()->getTarget());	}    }  midpoint = midpoint / size;  if (distance > 800)    {      vPlayer_[(*i)->getPlayerID()]->Moveback();      distance = 0;      midpoint = core::vector3df(0, 0, 0);      for (j = vPlayer_.begin(); j < vPlayer_.end(); j++)	{	  if ((*j)->isAlive())	    {	      pos = (*j)->getNode()->getPosition();	      // pos.Y = 0;	      midpoint += pos;	      distance += pos.getDistanceFrom(		      engine.Scene()->getActiveCamera()->getTarget());	    }	}      midpoint = midpoint / size;    }  for (k = vObject_.begin(); k < vObject_.end(); k++)    {      if (vPlayer_[(*i)->getPlayerID()]->getNode()->getTransformedBoundingBox().intersectsWithBox((*k)->getNode()->getTransformedBoundingBox()))	{	  std::cout << "COLLISION" << std::endl;	  (*k)->Take(vPlayer_[(*i)->getPlayerID()]);	}    }}void NsCore::Core::GameObjectTick(){  NsGUI::GraphicsEngine &engine = NsGUI::GraphicsEngine::Instance();  vObject_.erase(std::remove_if(vObject_.begin(), vObject_.end(), [&](auto i)  {    if ((*i).getNode()->isVisible() == true)      return (false);    for (auto j = this->Spawn_.getRooms_().begin(); j < this->Spawn_.getRooms_().end(); j++)      {	if ((*j).getDoor_() != NULL)	  {	    if ((*j).getDoor_()->getNode() == (*i).getNode())	      {		int	w = 0;		for (auto k = vPlayer_.begin(); k < vPlayer_.end(); k++)		  {		    std::cout << "NULL" << std::endl;		    (*k)->getNode()->removeAnimator((*j).getDoor_()->getPAnimator()[w]);		    w++;		  }		(*j).setDoor_(NULL);	      }	  }      }    this->DeleteEntityScreen<NsGameObject::GameObject&>(*i);    return (true);  }), vObject_.end());}void NsCore::Core::generateMonsters(std::vector<Room>::iterator i){  if ((*i).isActive())    {      while ((*i).getNbMonster_() < (*i).getNbmaxMonster_())	this->PushEnnemyEntity(std::make_shared<NsEntity::BasicMonster>(NsManager::NsModelsManager_.getModel("basicmonster")), (*i).GenerateMonster(), this->selector, (*i).getRoomId_());      if ((*i).getLevel_() == 10)	{	  this->PushEnnemyEntity(		  std::make_shared<NsEntity::Boss>(NsManager::NsModelsManager_.getModel("boss")),		  irr::core::vector3df(-1116.83,205,-4562.27), this->selector, (*i).getRoomId_());	}    }}void NsCore::Core::generateGoldKey(std::vector<Room>::iterator i){  if (!(*i).isActive())    {      while ((*i).getNbGold_() < (*i).getNbMaxGold_())	this->PushGameObject(std::make_shared<NsGameObject::Gold>(NsManager::NsModelsManager_.getModel("coin")), (*i).GenerateGold(), this->selector);      this->PushGameObject(std::make_shared<NsGameObject::Key>(NsManager::NsModelsManager_.getModel("key")), (*i).GenerateKey(), this->selector);    }}scene::ITriangleSelector *NsCore::Core::getSelector() const{  return selector;}void NsCore::Core::RoomsTick(){  for (auto j = this->Spawn_.getRooms_().begin(); j < this->Spawn_.getRooms_().end(); j++)    {      if ((*j).getDoor_() != NULL)	{	  (*j).getDoor_()->checkFrame();	  if ((*j).getDoor_()->isOpen() == 1)	    {	      (*j).setActive(true);	      this->generateMonsters(j);	      (*j).getDoor_()->setOpen(-1);	      actual_room = (*j).getLevel_();	    }	}    }  for (auto i = this->Spawn_.getRooms_().begin(); i < this->Spawn_.getRooms_().end(); i++)    {      if ((*i).getDoor_() != NULL)	(*i).getDoor_()->checkFrame();      if ((*i).isActive())	(*i).setNbMonster_(0);    }  for (auto i = this->vEnnemy_.begin(); i < this->vEnnemy_.end(); i++)    {      for (auto j = this->Spawn_.getRooms_().begin(); j < this->Spawn_.getRooms_().end(); j++)	{	  if ((*j).getDoor_() != NULL)	    (*j).getDoor_()->checkFrame();	  if ((*j).isActive() && (*i)->getRoom_id_() == (*j).getRoomId_())	    (*j).setNbMonster_((*j).getNbMonster_() + 1);	}    }  for (auto j = this->Spawn_.getRooms_().begin(); j < this->Spawn_.getRooms_().end(); j++)    {      if ((*j).getDoor_() != NULL)	(*j).getDoor_()->checkFrame();      if ((*j).isActive() && (*j).getNbMonster_() == 0)	{	  (*j).setActive(false);	  this->generateGoldKey(j);	}    }}void NsCore::Core::generateDoors(){  for(auto i = this->Spawn_.getRooms_().begin(); i < this->Spawn_.getRooms_().end(); i++)    {      NsGUI::GraphicsEngine &engine = NsGUI::GraphicsEngine::Instance();      std::shared_ptr<NsGameObject::Door> e = 0;      if ((*i).getType_() == 1)	e = std::make_shared<NsGameObject::Door>(NsManager::NsModelsManager_.getModel("door"));      if ((*i).getType_() == 2)	e = std::make_shared<NsGameObject::Door>(NsManager::NsModelsManager_.getModel("door2"));      if ((*i).getType_() == 3)	e = std::make_shared<NsGameObject::Door>(NsManager::NsModelsManager_.getModel("door3"));      (*i).setDoor_(e.get());      e->setType((*i).getType_());      std::shared_ptr<NsGameObject::GameObject> entity = e;      irr::scene::IAnimatedMeshSceneNode *node = engine.Scene()->addAnimatedMeshSceneNode(entity->getModel3D_().getMesh());      node->setPosition((*i).getDoorPos());      node->setMaterialFlag(irr::video::EMF_LIGHTING, false);      node->setRotation((*i).getRotation_());      core::aabbox3df box = node->getBoundingBox();      core::vector3df radius = box.MaxEdge - box.getCenter();      scene::ISceneNodeAnimator* anim = engine.Scene()->createCollisionResponseAnimator(selector, node, radius,											core::vector3df(0,-10,0), core::vector3df(0,0,0));      node->addAnimator(anim);      scene::ITriangleSelector* selec = 0;      selec = engine.Scene()->createOctreeTriangleSelector(	      node->getMesh(), node, 128);      node->setTriangleSelector(selec);      //! Add collisions for players      for (auto j = vPlayer_.begin(); j < vPlayer_.end(); j++)	{	  core::aabbox3df b = (*j)->getNode()->getBoundingBox();	  core::vector3df r = b.MaxEdge - b.getCenter();	  scene::ISceneNodeAnimator *a = engine.Scene()->createCollisionResponseAnimator(selec, (*j)->getNode(), r,											 core::vector3df(0,0,0), core::vector3df(0,0,0));	  (*j)->getNode()->addAnimator(a);	  (*i).getDoor_()->getPAnimator().push_back(a);	}      node->setScale(core::vector3df(100, 100, 100));      node->setAnimationSpeed(0);      entity->setNode_(node);      entity->Initialization();      vObject_.push_back(entity);    }}void NsCore::Core::setCameraStart(){  NsGUI::GraphicsEngine &engine = NsGUI::GraphicsEngine::Instance();  core::vector3df pos(0, 0, 0);  int 				size = 0;  distance = 0;  midpoint = pos;  for (auto j = vPlayer_.begin(); j < vPlayer_.end(); j++)    {      if ((*j)->isAlive())	{	  size++;	  pos = (*j)->getNode()->getPosition();	  // pos.Y = 0;	  midpoint += pos;	  distance += pos.getDistanceFrom(engine.Scene()->getActiveCamera()->getTarget());	}    }  midpoint = midpoint / size;}void	NsCore::Core::free_world(){  vPlayer_.erase(std::remove_if(vPlayer_.begin(), vPlayer_.end(), [&](auto i)  {    this->DeleteEntityScreen<NsEntity::PlayableEntity&>(*i);    return (true);  }), vPlayer_.end());  vPlayer_.clear();  vProjectil_.erase(std::remove_if(vProjectil_.begin(), vProjectil_.end(), [&](auto i)  {    this->DeleteEntityScreen<NsProjectil::Projectil&>(*i);    return (true);  }), vProjectil_.end());  vProjectil_.clear();  vObject_.erase(std::remove_if(vObject_.begin(), vObject_.end(), [&](auto i)  {    this->DeleteEntityScreen<NsGameObject::GameObject&>(*i);    return (true);  }), vObject_.end());  vObject_.clear();  vEnnemy_.erase(std::remove_if(vEnnemy_.begin(), vEnnemy_.end(), [&](auto i)  {    this->DeleteEntityScreen<NsEntity::EnnemyEntity&>(*i);    return (true);  }), vEnnemy_.end());  vEnnemy_.clear();  _state.clear();  Spawn_.getRooms_().clear();}int NsCore::Core::check_end(){  std::vector<std::shared_ptr<NsEntity::PlayableEntity>>::iterator j;  int		count = 0;  for (j = vPlayer_.begin(); j < vPlayer_.end(); j++)    {      if ((*j)->isAlive())	count++;    }  if (count == 0)    {      GAMESTATE_ = NsCore::GAMESTATE::MENU;      return (-1);    }  count = 0;  for (auto k = this->Spawn_.getRooms_().begin(); k < this->Spawn_.getRooms_().end(); k++)    {      if ((*k).getDoor_() == NULL && (*k).getLevel_() == 10 && (*k).getNbMonster_() == 0)	{	  GAMESTATE_ = NsCore::GAMESTATE::MENU;	  return (1);	}    };  return (0);}